#include <glm/glm.hpp>
#include <glm/gtx/matrix_major_storage.hpp>
#include <tga/TGAImage.h>
#define TINYOBJLOADER_USE_MAPBOX_EARCUT
#include <tiny_obj_loader.h>

#include <Simple-3D-Renderer/Math/util.h>
#include <Simple-3D-Renderer/Settings/config.h>

#include <iostream>
#include <cstring>
#include <stdlib.h>
#include <limits>

#define WHITE TGAColor(255, 255, 255, 255)
#define RED TGAColor(255, 0, 0, 255)
#define GREEN TGAColor(0, 255, 0, 255)

glm::fvec3 lightDir(0, 0, -1);

float getLightIntensity(const glm::fvec3& normal, const glm::fvec3& lightDir)
{
   return glm::dot(lightDir, normal);
}


glm::mat4 getPerspectiveM(float aspect, float fov, float zNear, float zFar)
{
   //save this as global const
   fov = 1 / glm::tan(fov / 2);
   float normalization[2] = {
      zFar / (zFar - zNear),
      (-zFar * zNear) / (zFar - zNear)
   };

   glm::mat4 PERSPECTIVE(0.0);
   PERSPECTIVE[0][0] = aspect * fov;
   PERSPECTIVE[1][1] = fov;
   PERSPECTIVE[2][2] = normalization[0];
   PERSPECTIVE[2][3] = normalization[1];
   PERSPECTIVE[3][2] = 1;

   return PERSPECTIVE;
}

// .It tells us:
//    1) Which side of the line the point is on(in counter-clockwise form):
//       e(p) > 0 -> inside the triagle
//       e(p) = 0 -> on the edge
//       e(p) < 0 -> outside of the triangle
//    2) The area of the parallelogram formed by these 3 vertices.
//
// .Also, this is the same as the 2D cross product of the vectors:
//
//    A = (p - v1)
//    B = (v1 - v2)
//
float edgeFunction(
      const glm::vec3& v1,
      const glm::vec3& v2,
      const glm::vec2& p
) {
   //return (p.x - v1.x) * (v2.y - v1.y) - (p.y - v1.y) * (v2.x - v1.x);
   return (v1.x - v2.x) * (p.y - v1.y) - (v1.y - v2.y) * (p.x - v1.x);
}

// In addition to telling us if the point is in the triangle, It also
// gives us the area of the parallelograms(or the area of the triangles
// multiplied by 2) forms by V1V2P, V1V3P and V2V3P.
bool isPointInTriangle(
      const glm::ivec3 (&v)[3],
      const glm::ivec2& p,
      float (&area)[3]
) {
   area[0] = edgeFunction(v[1], v[2], p);
   area[1] = edgeFunction(v[2], v[0], p);
   area[2] = edgeFunction(v[0], v[1], p);

   for (int i = 0; i < 3; i++)
   {
      if (area[i] < 0)
         return false;
   }

   return true;
}

glm::fvec3 getBarycentricCoords(
      glm::ivec3 (&v)[3],
      const float area,
      const glm::vec2& p
) {
   glm::fvec3 bc(-1);

   float miniArea[3];
   
   if (isPointInTriangle(v, p, miniArea))
   {
      bc.x = miniArea[0] / area;
      bc.y = miniArea[1] / area;
      bc.z = 1 - bc.x - bc.y;
   }

   return bc;
}

void getBoundingBoxes(
      const glm::ivec3 (&v)[3],
      glm::ivec2& boundingBoxMin,
      glm::ivec2& boundingBoxMax
) {
   boundingBoxMin = glm::ivec2(
         config::RESOLUTION_WIDTH - 1,
         config::RESOLUTION_HEIGHT - 1
   );
   boundingBoxMax = glm::ivec2(0, 0);
   glm::ivec2 clamp = boundingBoxMin;

   for (int i = 0; i < 3; i++)
   {
      boundingBoxMin.x = std::max(
            0,
            std::min(boundingBoxMin.x, v[i].x)
      );
      boundingBoxMin.y = std::max(
            0,
            std::min(boundingBoxMin.y, v[i].y)
      );

      boundingBoxMax.x = std::min(
            clamp.x,
            std::max(boundingBoxMax.x, v[i].x)
      );
      boundingBoxMax.y = std::min(
            clamp.y,
            std::max(boundingBoxMax.y, v[i].y)
      );
   }

}

float getDepth(const glm::ivec3 (&v)[3], const glm::fvec3& bc)
{
   return v[0].z * bc.x + v[1].z * bc.y + v[2].z * bc.z;
}


void fixOrder(glm::ivec3 (&v)[3], glm::fvec2 (&t)[3], float (&li)[3])
{
   if (v[0].y > v[1].y)
   {
      util::swap(v[0], v[1]);
      util::swap(t[0], t[1]);
      std::swap(li[0], li[1]);
   }
   if (v[0].y > v[2].y)
   {
      util::swap(v[0], v[2]);
      util::swap(t[0], t[2]);
      std::swap(li[0], li[2]);
   }
   if (v[1].y > v[2].y)
   {
      util::swap(v[1], v[2]);
      util::swap(t[1], t[2]);
      std::swap(li[1], li[2]);
   }
}

void drawTriangle(
   glm::ivec3 (&v)[3],
   glm::fvec2 (&t)[3],
   float (&li)[3],
   TGAImage& image,
   TGAImage& texture,
   float (&zBuffer)[config::RESOLUTION_WIDTH][config::RESOLUTION_HEIGHT]
) {

   //fixOrder(v, t, li);

   float area = edgeFunction(v[0], v[1], v[2]);
   // If The triangle is degenareted or clockwise
   if (area <= 0)
      return;
   
   glm::ivec2 boundingBoxMin, boundingBoxMax;
   getBoundingBoxes(v, boundingBoxMin, boundingBoxMax);

   glm::ivec2 p;
   for (p.x = boundingBoxMin.x; p.x <= boundingBoxMax.x; p.x++)
   {
      for (p.y = boundingBoxMin.y; p.y <= boundingBoxMax.y; p.y++)
      {
         glm::fvec3 bc = getBarycentricCoords(v, area, p);

         // It means that the point is outside of the triangle.
         if (bc.x == -1 || bc.y == -1 || bc.z == -1)
            continue;
         std::cout << "BC: " << bc.x << " " << bc.y << " " << bc.z << std::endl;

         float depth = getDepth(v, bc);
         
         if (depth < zBuffer[p.x][p.y])
         {
            zBuffer[p.x][p.y] = depth;

            float u = t[0].x * bc.y + t[1].x * bc.z + t[2].x * bc.x;
            float v = t[0].y * bc.y + t[1].y * bc.z + t[2].y * bc.x;

            //TGAColor ppp = texture.get(tt.x, tt.y);
            //std::cout << "COLOR: " << ppp.bgra[2] << " " << ppp.bgra[1] << " " << ppp.bgra[0] << std::endl;

            //image.set(p.x, p.y, texture.get(tt.x, tt.y));
            //----------------------------------
            float lightIntensity = li[0] * bc.y + li[1] * bc.z + li[2] * bc.x;

            // En este caso justo coincide que lo usamos como face culling
            // porq la camara esta en la cordenada (0,0,0)
            if (lightIntensity > 0)
            {
               image.set(
                     p.x,
                     p.y,
                     //TGAColor(lightIntensity * 255, lightIntensity * 255, lightIntensity * 255, 255)
                     //texture.get(u * config::RESOLUTION_WIDTH, v * config::RESOLUTION_HEIGHT)
                     WHITE
               );
            }
            image.set(p.x, p.y, WHITE);
         }
      }
   }
}


bool isInClipSpace(const glm::ivec3 (&screenCoords)[3])
{
   for (int i = 0; i < 3; i++)
   {
      if (std::abs(screenCoords[i].x) > config::RESOLUTION_WIDTH ||
          std::abs(screenCoords[i].y) > config::RESOLUTION_HEIGHT)
         return false;
   }
   return true;
}

// Transform world coordinates to screen coordinates.
glm::ivec3 getScreenCoords(const glm::fvec4& worldCoords)
{
   return glm::ivec3(
         (worldCoords.x + 1.0) * config::HALF_RESOLUTION_WIDTH,
         (worldCoords.y + 1.0) * config::HALF_RESOLUTION_HEIGHT,
         worldCoords.z
   );
}

glm::ivec2 getTexelCoords(
      const float u,
      const float v,
      const TGAImage& texture
) {
   return glm::ivec2(u * texture.width(), v * texture.height());
}

int main()
{
   TGAImage image(
         config::RESOLUTION_WIDTH,
         config::RESOLUTION_HEIGHT,
         TGAImage::RGB
   );

   TGAImage texture;
   texture.read_tga_file("../assets/texture/head.tga");
   tinyobj::ObjReaderConfig readerConfig;
   readerConfig.mtl_search_path = "./";
   tinyobj::ObjReader reader;

   if (!reader.ParseFromFile(config::MODEL_TO_READ, readerConfig))
   {
      if (!reader.Error().empty())
         std::cerr << "TinyObjReader: " << reader.Error();
   }
   if (!reader.Warning().empty()) {
      std::cout << "TinyObjReader: " << reader.Warning();
   }

   auto& attrib = reader.GetAttrib();
   auto& shapes = reader.GetShapes();


   float zBuffer[config::RESOLUTION_WIDTH][config::RESOLUTION_HEIGHT];
   for (int i = 0; i < config::RESOLUTION_WIDTH; i++)
      for (int j = 0; j < config::RESOLUTION_HEIGHT; j++)
         zBuffer[i][j] = std::numeric_limits<float>::max();

   for (size_t s = 0; s < shapes.size(); s++)
   {
      // Loop over faces(polygon)
      size_t index_offset = 0;

      for (size_t f = 0; f < shapes[s].mesh.num_face_vertices.size(); f++)
      {
         glm::fvec4 worldCoords[3];
         glm::ivec3 screenCoords[3];
         glm::fvec2 textureCoords[3];
         float lightIntensity[3];

         size_t fv = size_t(shapes[s].mesh.num_face_vertices[f]);

         // Loop over vertices in the face.
         for (size_t v = 0; v < fv; v++) {

            // access to vertex
            tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];

            worldCoords[v].x = attrib.vertices[3*size_t(idx.vertex_index)+0];
            worldCoords[v].y = attrib.vertices[3*size_t(idx.vertex_index)+1];
            worldCoords[v].z = attrib.vertices[3*size_t(idx.vertex_index)+2];
            worldCoords[v].w = 1.0;

            // Check if `texcoord_index` is zero or positive. negative = no texcoord data
            if (idx.texcoord_index >= 0)
            {
               float u = attrib.texcoords[2*size_t(idx.texcoord_index)+0];
               float v = attrib.texcoords[2*size_t(idx.texcoord_index)+1];

               //textureCoords[int(v)] = getTexelCoords(u, v, texture);
               textureCoords[int(v)] = glm::fvec2(u, v);
            }

            // Check if `normal_index` is zero or positive. negative = no normal data
            if (idx.normal_index >= 0)
            {
               glm::fvec3 normal;
               normal.x = attrib.normals[3*size_t(idx.normal_index)+0];
               normal.y = attrib.normals[3*size_t(idx.normal_index)+1];
               normal.z = attrib.normals[3*size_t(idx.normal_index)+2];

               lightIntensity[v] = getLightIntensity(normal, lightDir);
            }

            //glm::mat4 PERSPECTIVE =getPerspectiveM(
            //      config::ASPECT,
            //      180,
            //      1,
            //      -1
            //);
            //glm::vec4 tmp = PERSPECTIVE * worldCoords[v];
            //screenCoords[v] = glm::vec3(
            //      tmp.x / tmp.w,
            //      tmp.y / tmp.w,
            //      tmp.z / tmp.w
            //);
            screenCoords[v] = getScreenCoords(worldCoords[v]);
         }
         if (isInClipSpace(screenCoords))
         {
            drawTriangle(
                  screenCoords,
                  textureCoords,
                  lightIntensity,
                  image,
                  texture,
                  zBuffer
            );
         }

         index_offset += fv;
      }
   }

   //image.flip_vertically();
   image.write_tga_file("../output/output.tga");

   return 0;
}
